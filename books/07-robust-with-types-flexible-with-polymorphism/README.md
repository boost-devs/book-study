<div align="center">
  <a href="https://product.kyobobook.co.kr/detail/S000210397750">
      <img src="./img/thumbnail.png" alt="Logo" width="200">
  </a>
  <h1>타입으로 견고하게 다형성으로 유연하게</h1>
  <div>
    <img src="https://img.shields.io/badge/%EC%A0%80%EC%9E%90-홍재민-e76f51?style=for-the-badge"/>
    <img src="https://img.shields.io/badge/%EC%B6%9C%ED%8C%90%EC%82%AC-인사이트-faa307?style=for-the-badge"/>
    <img src="https://img.shields.io/badge/%EA%B8%B0%EA%B0%84-2024.06.10%20~%20-52b788?style=for-the-badge"/>
  </div>
</div>

## 📝 목차

- [1장. 타입 검사 훑어보기](#1장-타입-검사-훑어보기)
- [2장. 서브 타입에 의한 다형성](#2장-서브-타입에-의한-다형성)
- [3장. 매개변수에 의한 다형성](#3장-매개변수에-의한-다형성)
- [4장. 두 다형성의 만남](#4장-두-다형성의-만남)
- [5장. 오버로딩에 의한 다형성](#5장-오버로딩에-의한-다형성)
- [💬 느낀점](#-느낀점)

---

## 1장. 타입 검사 훑어보기

> <strong><i>p3. 타입은 프로그램에 존재하는 값(value)들을 그 능력에 따라 분류한 것이다.</strong></i> 🌵

> <strong><i>p8. 아무리 기술이 발전하고 대단한 천재가 나와도 이런 타입 검사기를 절대 만들 수 없다는 사실이 논리적으로 이미 증명되어 있다. 이는 무려 1930년대에 컴퓨터의 아버지 튜링이 직접 증명한 사실이다.</strong></i> 🐧

> <strong><i>p26. 타입 검사기가 a ? b : c를 검사할 때는 a의 계산 결과를 전혀 고려하지 않는다. a가 아무리 간단한 부품이더라도 말이다. '계산 결과를 절대 알아내려 하지 않는다'는 타입 검사의 원칙은 다른 모든 부품에도 똑같이 적용된다.</strong></i> 🌵🍋

> <strong><i>p47. 타입 표시는 '절대로 낡지 않는 주석'인 셈이다.</strong></i> 🌵🍋

> <strong><i>p50. 타입 추론은 생략된 타입 표시를 보구할 뿐이다. 타입 표시를 생략하는 거지, 타입 검사를 생략하는 게 아니다. 즉, 타입 검사 중에 생략된 매개변수 타입에 해당하는 타입을 찾을 수 있어야 한다.</strong></i> 🐧🍋

> <strong><i>p55. 앞에서 타입은 '프로그램에 존재하는 값들을 그 능력에 따라 분류한 것'이라 했다... 그러므로 어떤 언어에서는 타입 오류라 볼 수 없었던 버그가 다른 언어에서는 타입 오류가 되는 것이다.</strong></i> 🍋

> <strong><i>p57. 결과적으로 타입이라는 개념의 유연함은 언어 설계자와 개발자에게 여러 섲ㄴ택지를 제공한다. 값을 분류하는 방법에 따라 어떤 오류가 타입 요류가 될 수도 있고 그렇지 않을 수도 있다. 언어 설계자가 개발자의 자유에 가치를 둔다면 값을 대강 분류하도록 타입 검사기를 만들 것이다. ... 반대로 언어 설계자가 더 많은 버그를 찾는 데 가치를 둔다면 값을 더 세밀하게 분류한다.</strong></i> 🐧

> <strong><i>p57. 미국의 수학자 커리(Haskell Curry)와 논리학자 하워드(William Alvin Howard)가 밝혀낸 사실에 따르면 프로그램에 관한 임의의 성질을 타입으로 표현할 수 있다.</strong></i> 🌵

> <strong><i>p62. 다형성(polymorphism)은 타입 검사기의 오판을 줄이는 안전한 기능의 대부분을 차지하는 개념이다.</strong></i> 🌵

- `펭귄`: 노바 캔 스탑 하이퍼 스텔라~

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

## 2장. 서브 타입에 의한 다형성

> <strong><i>p78. 이름에 의한 서브타입을 사용하는 경우, 타입 검사기는 타입이 보여 주는 클래스와 이름과 클래스 사이의 상속 관계만 고려한다.</i></strong> 🐧

> <strong><i>p84. 구조에 의한 서브타입을 사용하는 경우, 타입 검사기는 클래스 사이의 상ㅅ혹 관계 대신 클래스의 구조, 즉 각 클래스에 어떤 필드와 메서드가 있는지 고려한다. 클래스 A가 클래스 B에 정의된 필드와 메서드를 모두 정의한다면 A는 B의 서브타입이다.</i></strong> 🐧

> <strong><i>p88. 다른 코드는 하나도 건드리지 않고 매개변수 타입표시를 { String email; }로 고치기만 해서 모든 문제를 해결한 것이다.</strong></i> 🍋

> <strong><i>p97. 단지 sendNewYearEmail이 타입 검사를 통과할 수 있도록 특정 객체가 sendEmail 메서드를 가진다는 사실을 표현하기 위해 만든 타입일 뿐이다.</strong></i> 🍋

> <strong><i>p97. 추상 클래스를 만드는 목적은 언제나 메서드의 존재에 관한 정보를 타입 검사기에 제공하려는 것이다. 그 자체로 객체를 만들려는 게 아니다.</i></strong> 🐧

> <strong><i>p97. 언어가 구조에 의한 서브타입을 제공한다면 추상 메서드의 필요성이 다소 줄어든다.</strong></i> 🌵

> <strong><i>p106. 최대 타입은 모든 타입의 슈퍼타입이다.</strong></i> 🌵

> <strong><i>114. Void는 함수가 계산을 끝낼 때 아무 값도 반환하지 않는다는 사실을 나타내지만, 최소 타입은 함수가 계산을 끝마치지 못한다는 사실을 나타낸다.</strong></i> 🍋

> <strong><i>p115. 최소 타입은 '계산을 끝마치지 못한다'를 표현하니 계산이 끝날 일도 없고 상자가 열릴 일도 없다. 이는 최소 타입에 속하는 값이 존재하지 않는다는 사실과도 일맥상통한다.</strong></i> 🌵

> <strong><i>p121. 그래서 이거나 타입을 제공하는 언어는 위치에 민감한 타입 검사라는 정교한 방식의 타입 검사를 사용한다. 변수의 값을 읽는 부품의 타입을 검사할 때 해당 변수가 정의된 곳의 타입 표시만 보는 것이 아니라, 그 변수가 어디서 사용되는지도 고려하는 것이다.</strong></i> 🍋

> <strong><i>123. 위치에 민감한 타입 검사가 잘 작동하도록 프로그램의 구조를 단순하게 만들어야 한다는 것이다.</strong></i> 🍋

> <strong><i>p129. 이면서 타입은 다중 상속이 있을 때 유용하다. 다중 상속은 한 클래스가 여러 클래스를 직접 상속하는 것을 말한다.</strong></i> 🌵🍋

- `펭귄`: 노바 캔 스탑 하이퍼 스텔라~

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

## 3장. 매개변수에 의한 다형성

> <strong><i>p0. 수수수수퍼노바</strong></i> 🐧🍋🌵

- `펭귄`: 노바 캔 스탑 하이퍼 스텔라~

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

## 4장. 두 다형성의 만남

> <strong><i>p0. 수수수수퍼노바</strong></i> 🐧🍋🌵

- `펭귄`: 노바 캔 스탑 하이퍼 스텔라~

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

## 5장. 오버로딩에 의한 다형성

> <strong><i>p0. 수수수수퍼노바</strong></i> 🐧🍋🌵

- `펭귄`: 노바 캔 스탑 하이퍼 스텔라~

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 💬 느낀점

<table>
  <thead>
    <tr>
      <th width='10%'>팀원</th>
      <th width='90%'>느낀점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align='center'><code>펭귄</code></td>
      <td></td>
    </tr>
    <tr>
      <td align='center'><code>샐리</code></td>
      <td></td>
    </tr>
    <tr>
      <td align='center'><code>튜브</code></td>
      <td></td>
    </tr>
  </tbody>
</table>

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>
