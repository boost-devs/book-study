# Clean Code 클린 코드

![저자](https://img.shields.io/badge/%EC%A0%80%EC%9E%90-%EB%A1%9C%EB%B2%84%ED%8A%B8%20C.%20%EB%A7%88%ED%8B%B4-e76f51?style=for-the-badge) ![출판사](https://img.shields.io/badge/%EC%B6%9C%ED%8C%90%EC%82%AC-%EC%9D%B8%EC%82%AC%EC%9D%B4%ED%8A%B8-faa307?style=for-the-badge) ![기간](https://img.shields.io/badge/%EA%B8%B0%EA%B0%84-2022.02.15%20~-52b788?style=for-the-badge)

- [1장. 깨끗한 코드](#1장-깨끗한-코드)
- [2장. 의미 있는 이름](#2장-의미-있는-이름)
- [3장. 함수](#3장-함수)
- [4장. 주석](#4장-주석)
- [5장. 형식 맞추기](#5장-형식-맞추기)
- [6장. 객체와 자료 구조](#6장-객체와-자료-구조)
- [7장. 오류 처리](#7장-오류-처리)
- [느낀점](#느낀점)

## 1장. 깨끗한 코드

**p2 헛소리! 앞으로 코드가 사라질 가망은 전혀 없다! 왜? 코드는 요구사항을 상세히 표현하는 수단이니까! 🐧**

- `펭귄`: 요새 인공지능이 개발자를 대체한다는 소리가 나오는데, 나보다는 코딩테스트를 잘 볼 수 있겠지만은 인공지능이 기획안을 이해할 수 있을 것 같진 않다.
- `튜브`: 10년 전에도 같은 고민을 했다고 한다. 하지만 적어도 당분간은 그런 일은 일어날 것 같지는 않다.

**p4 회사가 망한 원인은 바로 나쁜 코드 탓이었다. 🌵**

**p7 나쁜 코드를 양산하면 기한을 맞추지 못한다. 오히려 엉망진창인 상태로 인해 속도가 곧바로 늦어지고, 결국 기한을 놓친다. 기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다. 🐧🍋**

- `펭귄`: 나쁜 코드를 짜면 나중에 기능 구현 시 그 코드를 이해하느라 추가로 시간이 걸린다. 처음부터 좋은 코드를 짜서 이해하는 시간을 줄이는 게 좋은 것 같다.

**p7 좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다. 🍋🌵**

- `샐리`: 우리도 프로그래밍 분야의 전문가라는 생각과 책임감을 가지고 클린코드를 지켜야한다.
- `펭귄`: 나쁜 코드를 짤 때 항상 다른 곳에서 원인을 찾았는데 결국 짜는 나도 문제가 있음을 명심해야 겠다.

**p8 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다... '코드 감각'이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다. '코드 감각'으로 최고 방안을 선택한 후 여기서 거기까지 이동하는 경로를 계획한다. 🌵**

**p9 나쁜 코드는 나쁜 코드를 '유혹'한다! 🌵🍋**

- `샐리`: 나쁜코드가 다른 나쁜코드를 유혹하는 지에 대한 예시가 떠올랐다. 왜 나쁜코드를 짜면 안되는 지 잊어버렸을 때, 다시 읽어볼만한 구절(5쪽)

**p9 논리가 간단해야 버그가 숨어들지 못한다. 🙂**

- `후미`: 코드의 논리가 복잡하면 코드에 버그가 있을때 디버깅하기 굉장히 어려움. 또한 버그가 생겨 코드를 수정하게 되면 그 코드의 논리는 더욱 복잡해진다.
- `샐리`: 코드의 길이를 줄이는 것이 목표가 아니다. 간단한 논리와 직관적인 코드가 중요하다.
- `펭귄`: 갑자기 생각나는 [컴공 짤](https://www.google.com/search?q=%EC%BB%B4%EA%B3%B5+%EA%B3%A0%EC%88%98+%EC%B4%88%EB%B3%B4&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjHh8j2xpr2AhWyklYBHfbXAg0Q_AUoAXoECAEQAw&biw=1857&bih=977&dpr=1)

**p10 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다. 🐧**

- `펭귄`: 예외처리가 정말 중요한 것 같다.

**p10 깨끗한 코드는 한가지에 '집중'한다. 각 함수와 클래스와 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다. 🐧🙂**

- `펭귄`: 함수가 하나의 역할만 하는게 중요한 것 같다
- `후미`: 시간 복잡도 VS 함수별 한 기능
  - `펭귄`, `튜브`: 여러 상황을 고려해야할 것 같다.
  - `샐리`: 컴퓨터 상황도 고려해야 한다.

**p11 코드는 추측이 아니라 사실에 기반해야 한다. 반드시 필요한 내용만 담아야 한다. 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야 한다. 🐧🌵**

- `펭귄`: 코드한테는 단호할 필요가 있다.
- `튜브`: 모호하지 않은 코드와도 연관이 있는 것 같다.

**p12 - p13 깨끗한 코드는 주의 깊게 작성한 코드다. 누군가 시간을 들여 깔끔하고 단정하게 정리한 코드다. 자세한 사항까지 꼼꼼하게 신경 쓴 코드다. 주의를 기울인 코드다. 🐧**

- `펭귄`: 신입 개발자한테는 깔끔하고 정리한 코드를 고민하는 것보다는 “내가 구현할 수 있을까?”를 먼저 생각하게 되는 것 같다.

**p13 - p14 켄트 백이 제안한 단순한 코드 규칙으로 구현을 시작한다. … 모든 테스트를 통과한다. 🙂**

- `후미`: 테스트 케이스랑 단순한 코드랑 연관이 있나? 단순한이 코드가 아닌 코드 규칙을 수식한다.

**p14 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기. 🐧**

- `샐리`: 표현력을 높인다는 것의 의미는 프로그램 요구사항을 잘 반영한다는 것일지도

**p15 코드를 읽으면서 짐작했던 기능을 각 루틴이 수행한다면 깨끗한 코드라 불러도 되겠다. 🍋**

**p18 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10대 1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. 🌵🐧🙂🍋**

## 2장. 의미 있는 이름

**p23 각 개념에 이름만 붙여도 코드가 상당히 나아진다. 🌵🐧**

- `튜브`: 2장을 요약하는 한 마디 같다.

**p25 컴파일러나 인터프리터만 통과하려는 생각으로 코드를 구현하는 프로그래머는 스스로 문제를 일으킨다. 🍋🌵**

- `샐리`: 임베디드 소프트웨어 과목 때, 돌아가기만 하면 된다는 생각으로 짰었다. 결국 다시 짰다.
- `펭귄`: 타입스크립트 타입 검사 통과하기에 어쩔 수 없이 any를 쓰게 되는 내가 생각났다.
- `튜브`: 이름 짓기 귀찮아서 \_만 붙였던 과거의 내가 찔렸다.


**p25 일관성이 떨어지는 표기법은 그릇된 정보다. 🙂🐧**

- `후미`: 같은 단어뜻을 가진 여러 영단어를 혼용해서 사용해서 일관성이 떨어짐
- `샐리`: 일관성 있는 이름을 사용해야 데이터도 의미를 가질 수 있고, 쓰일 수 있다.
- `펭귄`: 회사에서 커밋 메시지를 구체화해서 적으려고 노력하는데, 나만의 커밋룰을 정해서 정리한 게 큰 도움이 되었다. 그만큼 일관성이 중요한 것 같다.
- `튜브`: 변수 이름 비롯해서 여러 규칙을 문서화하는 것이 중요한 것 같다.


**p26 불용어를 추가한 이름 역시 아무런 정보도 제공하지 못한다. ... 불용어는 중복이다.(a, an, the, variable) 🍋**

- `샐리`: 1학년 때, 시험 때 변수 이름으로 예약어를 써서 감점된 경험이 있다.

**p27 읽는 사람이 차이를 알도록 이름을 지어라. 🙂🌵**

- `후미`: 읽는 사람을 위한 코드를 짜자… 나중에는 내가 읽는 사람이 된다.

**p28 검색은 되었지만, 7을 사용한 의도가 다른 경우도 있다. 상수가 여러 숫자이고 누군가 상수 내 숫자 위치를 바꿨다면 문제는 더욱 심각해진다. 상수에 버그가 있으나 검색으로 찾아내지 못한다. 🐧🙂**

- `펭귄`: 리터럴을 쓰는 것보다는 상수로 정의해놓고 쓰는 이유.

**p35 addr라는 접두어를 추가해 addrFirstName, addrLastName, addrState라 쓰면 맥락이 좀 더 분명해진다. 변수가 좀 더 큰 구조에 속한다는 사실이 적어도 독자에게는 분명해진다. 🐧**

**p37 일반적으로 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서다. 이름에 불필요한 맥락을 추가하지 않도록 주의한다. 🐧**

- `펭귄`: 필요한 맥락과 불필요한 맥락 그 중간을 찾기가 어려운 것 같다.

**p38 사람들이 이름을 바꾸지 않으려는 이유 하나는 다른 개발자가 반대할까 두려워서다. 오히려 (좋은 이름으로 바꿔주면) 반갑고 고맙다. 우리들 대다수는 자신이 짠 클래스 이름과 매서드 이름을 모두 암기하지 못한다. 🌵**

**p38 여느 코드 개선 노력과 마찬가지로 이름 역시 나름대로 바꿨다가는 누군가 질책할지도 모른다. 그렇다고 코드를 개선하려는 노력을 중단해서는 안 된다. 🌵🍋**

#### N줄요약

1. 변수명은 꼭 필요한 정보만 넣어 간단명료하게 짓는다.(ex. 불용어 제거, 일관성 있는 이름, IDE 검색이 편하게)
2. 동일한 맥락에서 한 개념에 한 단어를 사용하자. 다른 맥락이라면, 단어를 구분하여 쓰자.
3. 변수명을 지을 때 우선순위는 개발자 용어, 그 다음은 도메인이다.
4. 추론하기 힘든 변수는 맥락을 추가하되, 누구나 유추가능한 맥락은 넣지 말자.


## 3장. 함수

**p43 각 함수가 이야기 하나🙂**

**p43 함수가 얼마나 짧아야 하느냐고? 일반적으로 목록 3-2보다 짧아야 한다! 사실 목록 3-2는 목록 3-3으로 줄여야 마땅하다. (3-2는 14줄, 3-3은 6줄..) 🌵**

- `튜브`: 정말 14줄이 길다고?
- `샐리`: 내 코드를 돌아보면, 3-2도 아닌, 3-1 수준의 코드였던 것을 반성한다.
- `후미`: 이 정도로 짧게 함수를 짤 수 있을까…  

**p44 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. 🍋🙂**

- `후미` : 지난번에 논의 했던 시간 복잡도를 고려하면 한 함수에 여러 기능을 넣어도 되는데 시간 복잡도 보다는 클린코드가 더 중요한 것 같다.
- `샐리`: 한 가지 역할을 하는 함수는 어떻게 정의되는가? 모호한 것 같다. (평균을 내는 함수는 더하는 함수와 길이로 나누는 부분으로 구성되어야하는가?)
- `튜브`: 어느 단위까지 쪼개야 할까?

**p45 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 어쨌거나 우리가 함수를 만드는 이유는 큰 개념을 (다시 말해, 함수 이름을) 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서가 아니던가. 🌵**

- `샐리`: 코드를 읽을 때, 이야기의 흐름을 서술식으로 나타낼 수 있다면 비슷한 추상화 단계라고 볼 수 있지 않을까? (만약 A라면, b, c, d를 하라 → 만약 A라면, B를 해라. B는 b, c, d로 구성되어있다. / A,B는 사람이 알아들을 수 있는 말. b,c,d는 기능적 이름)
- `튜브`: 함수 이름과 역할을 ‘추상화 수준’과 일치시킨다고 해석할 수 있을 것 같다. 

**p45 함수가 '한 가지'만 하는지 판단하는 방법이 하나 더 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. 🌵🍋**

- `샐리`: 이건 저자의 생각일 뿐, 우리는 적용할 수 있는 만큼만 받아들이면 될 것 같다!

**p46 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 🍋**

- `튜브`: 예제 3-2 → 3-3 에서도

**p46 한 함수내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 🙂**

**p49 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다. 🍋🌵**

- `샐리`: 유명하고 잘 짜인 오픈소스에서 내 함수의 이름과 구성을 참고할 수 있겠다!

**p49 함수가 작고 단순 할 수록 서술적인 이름을 고르기 쉬워진다. 🙂🌵🍋**

- `후미` : 함수를 짧게 짜라는 리마인드!!
- `튜브` : 거꾸로 ‘좋은 함수 이름을 짓다 보면 간결한 함수를 짤 수 있다’는 의미로 볼 수 있을 것 같다. 

**p50 함수에서 이상적인 인수 개수는 0개(무항)다. 🍋🌵**

- `샐리`: 부스트캠프 할 때, yaml 파일을 썼던 기억이 난다.

**p50 4개 이상은 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안 된다. 🌵**

- `샐리`: 53페이지에 인수객체 예제가 적절한 것 같다.
- `튜브`: 조금 가혹한 것 같기도 하다. 파이썬 함수 생각하면 예외도 있는 것 같다.

**p50 출력 인수는 입력 인수보다 이해하기 어렵다. 🍋**

- `샐리`: 코드에 출력인수를 표현해놓기란 쉽지 않다!

**p52 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다. 🌵**

**p54 함수에 인수 이름을 넣는다. 🙂**
- `후미` :  함수명을 `assertEquals` 보다 `assertExpectedEqualsActual`으로 쓰면 어떤 변수를 사용하는 지와 변수 위치를 쉽게 알 수 있다.

**p57 명령과 조회를 분리해 혼란을 뽑는다. 🙂🌵🍋**

**p59 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다. 🙂🍋🌵**

- `샐리`: if 문과 try-catch의 맥락의 차이가 분명 존재한다!

**p60 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손봐야 하니까. 🍋**

**p61 함수는 return 문이 하나여야 한다는 말이다. 루프 안에서 break나 continue를 사용해선 안되며 goto는 절대로, 절대로 안 된다. … 함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다. 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다. 🌵🍋**

## 4장. 주석

**p68 사실상 주석은 기껏해야 필요악이다. 🌵**

- `튜브` : 조금 과장된 표현인 것 같긴 하지만, 4장을 요약하는 한 줄인 듯

**p68 우리는 코드로 의도를 표현하지 못해, 그러니까 실패를 만회하기 위해 주석을 사용한다. 🙂🌵**

- `후미`: 찔리지만 억울하다..
- `펭귄`: 저자의 생각이 다소 극단적인 것 같다..

**p68 그러므로 주석이 필요한 상황에 처하면 곰곰이 생각하기 바란다. 상황을 역전해 코드로 의도를 표현할 방법은 없을까? 코드로 의도를 표현할 때마다 스스로를 칭찬해준다. 🐧**

- `펭귄`: 보통 주석은 내 코드에 설명에 필요하다 생각해 달았는데, 이런 태도보다는 더 깔끔한 코드를 짜도록 노력해야겠다.

**p68 주석은 오래될수록 코드에서 멀어진다. 오래될수록 완전히 그릇될 가능성도 커진다. 🍋🌵**

- `샐리`: 특히 상급자/타인의 코드/주석을 고치기란…부담스럽다. 시간이 지나며 틀리게 된 정보를 포함하더라도 그냥 지나치게 되는 것 같다.
- `튜브`: 리팩토링 할때도 일이 늘어날 수도 있을 것 같다.

**p73 주석이 올바른지 검증하기 쉽지 않다. 이것이 의미를 명료히 밝히는 주석이 필요한 이유인 동시에 주석이 위험한 이유이기도 하다. 🐧**

- `샐리`: 주석이 틀려도 코드는 돌아가니까, 주석이 틀리게될 수 있다는 경각심을 가져야할 것 같다.

**p75 주기적으로 todo 주석을 점검해 없애라. 🙂🍋🐧**

- `후미`: todo 많이 쓰는데 todo를 썼으면 나중에 그 기능을 구현하고 todo를 지우자..

**p76 이해가 안 되어 다른 모듈까지 뒤져야 하는 주석은 독자와 제대로 소통하지 못하는 주석이다. 🌵**

- `샐리`: 어차피 코드 다 들어가보는게 맘 편하다!

**p80 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 🌵**

- `튜브`: 쓰다 보면 정말로 다 있어야 하는가 하는 의문이 들 때가 있었다. / 그런데 쓰려면 다 쓰는 게 맞지 않나..?
- `펭귄`: 요새 IDE는 마우스 올리면 바로 함수 설명을 보여줘 따로 코드를 타고 들어가지 않아도 되서, 외부에서 사용하는 함수의 경우 웬만하면 Javadoc을 달면 좋을 것 같다. 🙂**

**p84 주석이 필요하지 않도록 코드를 개선하는 것이 좋다. 🙂**

**p85 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자. 🍋**

- `샐리`: “3장 함수" 부분과도 연관이 있는 부분인 것 같다. 닫는 괄호가 늘어난다면, 함수로 빼는 것도 방법이다!

**p85 배너(소스 파일에서 특정 위치를 표시)는 반드시 필요할때만, 아주 드물게 사용하는 편이 좋다. 🙂**

- `후미`: 맞는 말이다! 하지만 필요할 때도 있는거 같다..
- `펭귄`: 강의/실습 코드에서 쓰일 때는 괜찮은 것 같기도 하다.

**p86 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어 남겨놓았으리라고, 중요하니까 지우면 안 된다고 생각한다. 그래서 질 나쁜 와인병 바닥에 앙금이 쌓이듯 쓸모 없는 코드가 점차 쌓여 간다. 🍋🐧**

- `튜브`: 맞는 말이다. 하지만 용기가 필요하다.

**p87 소스 코드 관리 시스템이 우리를 대신해 코드를 기억해준다. 그냥 코드를 삭제하라. 🍋🐧**

**p88 주석을 달아야한다면 근처에 있는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라. 🍋🐧🌵**

**p89 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다. ... 주석 자체가 다시 설명을 요구하니 안타깝기 그지없다. 🍋**

**p89 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 좋다. 🍋**

```
# ====================================
#    			n줄요약
# ====================================
# 좋은 주석: 법적인 주석, 정보를 제공하는 주석, 의도를 설명하는 주석, 의미를 명료하게 밝히는 주석, 
#        결과를 경고하는 주석, TODO 주석, 중요성을 강조하는 주석, 공개 API에서 Javadocs
# 나쁜 주석: 주절거리는 주석, 같은 이야기를 중복하는 주석, 오해할 여지가 있는 주석, 의무적으로 다는 주석, 
#        이력을 기록하는 주석, 있으나 마나 한 주석, 무서운 잡음, 함수나 변수로 표현할 수 있다면 주석을 달지 마라, 
#        닫는 괄호에 다는 주석, 공로를 돌리거나 저자를 표시하는 주석, 주석으로 처리한 코드, HTML 주석, 전역 정보, 
#        너무 많은 정보, 모호한 관계, 함수헤더, 비공개 코드에서 Javadocs
```

## 5장. 형식 맞추기

**p96 전문가가 짰다는 인상을 심어주면 좋겠다. 그 대신에 술 취한 뱃사람 한 무리가 짜놓은 듯 어수선해 보인다면 독자들은 프로젝트의 다른 측면도 똑같이 무성의한 태도로 처리했으리라 생각할 것이다. 🍋**

- `샐리`: 깨진 유리창 효과처럼!

**p96 오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. 🍋🌵**
- `샐리`: “4장 주석"에서도 이야기 했듯이, 처음 짠 코드/주석이 나중에도 영향을 끼친다는 것을 기억하자!

**p98 독자는 위에서 아래로 기사를 읽는다. … 소스 파일도 신문 기사와 비슷하게 작성한다. 이름은 간단하면서도 설명이 가능하게 짓는다. 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다. 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세히 묘사한다. 마지막에는 가장 저차원 함수와 세부내역이 나온다. 🍋🐧**

- `펭귄`: 이번 장을 요약하면 위와 같지 않을까?
- `튜브`: 여전히 이름 짓는 것이 중요하다.

**p98 - p100 빈 행은 새로운 개념을 시작한다는 시각적 단서다. … 서로 밀접한 코드 행은 세로로 가까이 놓아야 한다는 뜻이다. 🍋**

- `샐리`: KNN이 생각나는 글..
- `튜브`: 빈 행을 써서 구분하는 것 좋지만, 너무 많은 빈행을 남발하면 안 된다. 적당히 쓰자.

**p101 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다. 여기서 연관성이란 한 개념을 이해하는 데 다른 개념이 중요한 정도다. 🌵🐧**

- `튜브`: ‘연관성’이라는 표현이 핵심을 적절히 표현하는 것 같다.

**p101 변수는 사용하는 위치에 최대한 가까이 선언한다. 🍋**

**p104 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 프로그램이 자연스럽게 읽힌다. 🍋🐧**

- `샐리`: 자주 호출하는 함수는 따로 헤더로 빼는 것도 괜찮지 않을까?

**p106 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다. 🌵**

- `튜브`: 아직은 호출할 함수가 위에 있는 것이 어색하기는 하다.

**p108 공백을 넣으면 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해진다. 🍋🌵**

- `샐리`: 앞서 말했던게 세로 연관성에 관련한 이야기였다면, 이건 가로 연관성에 관한 이야기이다.
- `튜브`: 연산자 우선순위를 공백으로 나타내는 것이 인상적이었다. (그래도 3*3 + 5는 좀 불편)

**p110 선언문과 할당문을 별도로 정렬하지 않는다. 🍋**

- `샐리`: 오히려 가독성이 떨어지고, 힘든 작업이다! 굳이 하지 말자!

**p113 지금까지 나는 while문 끝에 세미콜론(;) 하나를 살짝 덧붙인 코드로 수없이 골탕을 먹었다. 🍋**

- `샐리`: 꼭 고수들이 이러더라..++a, a++

**p114 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야한다. 🍋🌵**

## 6장. 객체와 자료 구조

**p118 - p119 어째서 수많은 프로그래머가 조회(get)함수와 설정(set)함수를 당연하게 공개(public)해 비공개 변수를 외부에 노출할까? ... 변수를 private으로 선언하더라도 각 값마다 조회(get)함수와 설정(set)함수를 제공한다면 구현을 외부로 노출하는 셈이다. 🍋**

**p119 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. 🍋🌵**

  - `튜브`: 앞에서 말한 이름 짓기의 연장선 + 이 장의 핵심 내용인 것 같다.

> p119 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 🍋**

  - `샐리`: 구조체(자료구조)와 클래스(추상화) 이야기인 것 같다.

**p122 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다! 🍋**

  - `샐리`: 절차 지향 코드는 새 함수를 추가하기 쉽고, 새 자료구조를 추가하기 어렵다. 객체 지향 코드는 그 반대! 나중에 이 차이를 잘 고려하여 코드를 짜자!

**p123 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 🍋🙂**

  - `후미`: 함수내에서 어떤 연산이 이루어지는지 알 필요 없고 단지 함수의 결과값만 알면 된다!

**p123 `final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();` 흔히 위와 같은 코드를 기차충돌(train wreck)이라 부른다. ... 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 🍋**

  - `튜브`: ‘기차 충돌 형태의 코드는 요즘 들어 읽기 쉬운 코드를 지향하는 fluent interface에 등장하고 있다.’ 고 합니다. (xxviii 페이지, 복간에 부쳐 중에) / 경우에 따라 다른 것 같다.
  - `후미`: 기차 충돌 방식으로 코드 flow를 보여주는 것도 좋은것 같음.
  - `샐리`: 명시적으로 형을 지정하는 방식은 도움이 될 것 같다. 변수 재활용성에 있어서도 장점일 것 같다.


**p124 객체라면 내부 구조를 숨겨야하므로 ... 반면, 자료 구조라면 당연히 내부 구조를 노출하므로 ... 🍋**

  - `샐리`: 객체와 자료 구조의 차이를 깨달은 것 같다.

**p125 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안 된다. 🍋🙂🌵**

  - `후미`: 객체는 이렇게 해야 맞는것 같다.

**p126 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)라 한다. 🍋**

**p126 좀 더 일반적인 형태는 '빈(bean)' 구조다. ... 빈은 비공개(private)변수를 조회/설정 함수로 조작한다. 일종의 사이비 캡슐화로, ... 별다른 이익을 제공하지 않는다. 🍋**

  - `샐리`: 커피"콩”, 가장 기본적인 형태를 말하는 것 같다!

**p127 활성 레코드는 DTO의 특수한 형태다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대개 save나 find와 같은 탐색 함수도 제공한다. ... 활성 레코드는 자료 구조로 취급한다. 🍋🌵**

**p127 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 호출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. (어떤) 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다. 🍋🌵**


## 7장. 오류 처리

**p130 뭔가 잘못되면 바로 잡을 책임은 바로 우리 프로그래머에게 있다. 🙂🐧**
  - `후미`: 개발자라면 당연히 프로그램을 만들면서 a/s도 해야된다.
  - `펭귄`: 이 책은 개발자에게 코드에 대한 책임감을 상기시킨다. 

**p131 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 더 깔끔해진다. 논리가 오류 처리 코드와 뒤섞이지 않으니까. 🌵**
  - `튜브`: 오류를 잘 잡는 것도 중요하지만 깔끔하게 짜는 것도 중요하다. (이 부분 앞뒤의 코드를 잘 설명해 주는 듯하다)
  - `펭귄`: 적절한 예외처리가 코드를 더 깔끔하게 한다.

**p133 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다. 🌵🐧**
  - `펭귄`: 원래는 로직부터 구현하고 여기서 에러가 나겠다 싶으면 오류처리를 해줬었다. 위의 방법으로 한 번 구현해봐야지..!
  - `후미`: 일단 당해봐야 미리 처리를 할것 같다.

**p135 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 🙂**
  - `후미`: 무슨 에러인지 정확히 명시를 해야 나중에 디버깅할때 편한다.
  - `펭귄`: 에러 모니터링 시 에러 메시지가 중요하다.

**p135 오류가 발생한 위치로 분류가 가능하다. ... 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다. 🌵**
  - `튜브`: 예외를 처리해서 중요한 것은 어떻게 처리하는 것이라는 점을 말하는 것 같다.

**p137 흔히 예외 클래스가 하나만 있어도 충분한 코드가 많다. 예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우가 그렇다. 🌵**
  - `후미`: 예시 코드에 있는 클래스는 모든 에러를 모아둔 클래스라고 생각. 데코레이터를 사용해 예외처리를 하니 훨씬 코드 읽기도 편해졌음.

**p138 이를 특수 사례 패던(Special Case Pattern)이라고 부른다. 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다. 그러면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로. 🐧**
  - `펭귄`: 남의 코드를 고치기 쉽지 않지만 더 효율적이고 간결한 코드를 위해서 용기를 내보자.
  - `튜브`: 무조건 예외 처리 코드를 써야 하는 것이 아니라, 코드를 잘 짜면 필요가 없을 수도


**p139 위 코드는 null 확인이 누란된 문제라 말하기 쉽다. 하지만 실상은 null 확인이 너무 많아 문제다. 메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. 사용하려는 외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다. 🌵🐧**
  - `펭귄`: 많이 찔렸는데, None을 반환하기 보다는 해당 자료형에 맞게 None을 표현할 수 있는 것을 사용하자.

**p140 null을 반환하기 보단 빈 리스트를 리턴하자. 🙂🌵🐧**
  - `후미`: 빈리스트나 공백(“”)을 반환하는게 통일성측면에서도 좋다.

**p142 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 즉, 인수로 null이 넘어오면 코드에 문제가 있다는 말이다. 이런 정책을 따르면 그만큼 부주의한 실수를 저지를 확률도 작아진다. 🌵🐧**
  - `펭귄`: return None은 lint로 금지시켜야한다.

**p142 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 🙂**

## 느낀점

|  팀원  | 느낀점 |
| :----: | :----- |
| `펭귄` |        |
| `샐리` |        |
| `후미` |        |
| `튜브` |        |
