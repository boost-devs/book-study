## 1장. 디자인 패턴 소개와 전략 패턴

생각보다 더 쉽게 잘 쓰여진 책이라는 것을 깨달았다.  
오리 시뮬레이션 게임과 같은 상황을 모두가 한번쯤은 경험/상상해보지 않았을까?  
내용 중, 나도 Joe 처럼 fly 메소드 추가하면 당연히 해결될 것이라 생각하며 글을 읽었는데, 생각치도 못한 '고무오리가 날아다니는 사건'이 발생했다.  
내가 이 책 속의 주인공이라면 과연 어떤 방법을 사용할지, 다른 방안은 무엇이 있는지 생각하면서 읽으니까 더욱 몰입이 되는 것 같다.  

슈퍼 클래스를 상속받기에는 상황이 너무 다양하고, 다른 인터페이스를 상속받아서 하위 클래스 내에서 구현하자니 코드 재활용이 안된다.  
이러한 상황이 트레이드오프라고 생각했었는데, 간단한(?) 패턴으로 이 문제를 해결할 수 있다니 패턴을 배우면 참 유용하게 쓸 수 있을 것 같다는 생각이 들었다.  
객체의 모체가 되는 클래스에서 행동(바뀌는 부분)을 분리한 후, 따로 구현하여 이 행동을 가져와서 사용하는 방식!  
이 방식을 사용하면 코드도 재활용할수도 있고, 동적으로 행동을 지정할수도 있고, 새로운 오리가 나와도 유연하게 대처할 수 있다.  
내가 보기엔 정말 완벽한 방식인 것 같은데, 책에서는 이보다도 더 좋은 방식이 있다는 것을 넌지시 알려주고 있다. 더 좋은 방법은 과연 무엇일까...  

사실, 누군가에게 이 방식을 설명하는 것은 어려운 일이다.  
그래서 이 책의 마지막 부근의 내용 중, 패턴을 알면 다른 동료들과 의사소통할 때 편리하게 구현 방식을 정할 수 있다고 한다.  
야구선수들이 서로 사인을 맞추듯, 개발자들도 사인을 맞추는 것 같다. `'전략패턴'을 사용하자!`라고 하듯이!


## 2장. 옵저버 패턴

옵저버 패턴은 어떤 이벤트가 발생한 것을 여러 객체가 주시하거나 필요로 할 때 사용할 수 있을 것 같다.  

오늘 내용은 그렇게 어렵지 않았다. 책이 쉽게 설명해줘서 그런 것 같다.
신문사와 구독자로 생각하고 읽으니, 풀/푸쉬에 대한 것도 정리가 잘 됐다.
내가 받고싶을 때만 받는 것은 풀, 내 의지와는 상관없이 알람이 오는 것이 푸쉬!
푸쉬 방법의 경우에는 옵저버가 많아질 때, 주제(subject)의 부하가 심할 것 같다는 생각이 들었는데, 마침 2장 뒷 부분에 손쉽게 풀로 변경하는 방법에 대해 나왔다.
update를 호출하는 주체가 누구냐에 따라 풀/푸쉬가 되는 걸까? 뭔가 이상하다고 생각이 들었지만, 한번 더 읽어봐야 알 것 같다.  

대학교 때, 자바 스윙을 사용하는 프로젝트를 한 적이 있다.
내부 구조에 대해서는 이해하지 못하고 단순히 이벤트가 발생하면, 액션리스너를 통해서 그 정보를 받아온다는 사실만 알고서도 프로그램을 짤 수 있었다.
이렇듯, 그 내부 구조를 몰라도 잘 작동하도록 만들어놓으면, 다른 개발자들도 유용하게 이를 가져다 쓸 수 있다는 사실을 이 책을 읽으며 다시 한번 상기했고, 나도 이렇게 '잘 짜여진' 프로그램을 만들어서 배포해보고 싶어졌다.

## 3장. 데코레이터 패턴

## 4장. 팩토리 패턴

## 5장. 싱글턴 패턴

## 6장. 커맨드 패턴

## 7장. 어댑터 패턴과 퍼사드 패턴

## 8장. 템플릿 메소드 패턴

## 9장. 반복자 패턴과 컴포지트 패턴

## 10장. 상태 패턴

## 11장. 프록시 패턴

## 12장. 복합 패턴

## 13장. 실전 디자인 패턴

## 14장. 기타 패턴
