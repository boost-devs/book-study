<div align="center">
  <a href="https://product.kyobobook.co.kr/detail/S000203107475">
      <img src="./img/thumbnail.png" alt="Logo" width="200">
  </a>
  <h1>육각형 개발자</h1>
  <div>
    <img src="https://img.shields.io/badge/%EC%A0%80%EC%9E%90-%EC%B5%9C%EB%B2%94%EA%B7%A0-e76f51?style=for-the-badge"/>
    <img src="https://img.shields.io/badge/%EC%B6%9C%ED%8C%90%EC%82%AC-%ED%95%9C%EB%B9%9B%EB%AF%B8%EB%94%94%EC%96%B4-faa307?style=for-the-badge"/>
    <img src="https://img.shields.io/badge/%EA%B8%B0%EA%B0%84-2024.01.11%20~%20-52b788?style=for-the-badge"/>
  </div>
</div>

## 📝 목차

- [1장. 들어가며](#1장-들어가며)
- [2장. 구현 기술과 학습](#2장-구현-기술과-학습)
- [3장. 소프트웨어 가치와 비용](#3장-소프트웨어-가치와-비용)
- [4장. 코드 이해](#4장-코드-이해)
- [5장. 응집도와 결합도](#5장-응집도와-결합도)
- [6장. 리팩터링](#6장-리팩터링)
- [7장. 테스트](#7장-테스트)
- [8장. 아키텍처 · 패턴](#8장-아키텍처--패턴)
- [9장. 업무 관리](#9장-업무-관리)
- [10장. 정리하고 공유하기](#10장-정리하고-공유하기)
- [11장. 리더와 팔로워](#11장-리더와-팔로워)
- [💬 느낀점](#-느낀점)

---

## 1장. 들어가며

> <strong><i>p18. 또 다른 문제도 있었다. 뜬금없이 중간 관리자 역할을 맞게 되었다. 이때의 관리자는 개발에 참여하지 않았다.</i></strong> 🐧🌵

- `튜브`: 이런 상황을 잘 헤쳐 나갈 수 있는 방법을 이 책에서 배울 수 있지 않을까?
- `샐리`: 중간 관리자가 코드를 짜진 않아도 구조는 알아야한다고 생각한다.
- `펭귄`: 확실히 관리자 직책을 맡으신 분들은 많이 바쁘신 것 같다.

> <strong><i>p22. 회사 업무를 하면서 성장한다는 느낌을 받지 못한 이유 중 하나는 개발(다양한 구현 기술 사용)과 성장을 동일시했기 때문이다.</i></strong> 🐧🐤

- `펭귄`: 확실히 특정 기술 스택을 아는 게 성장이 아니고 코드를 볼 때 나무가 아니라 숲을 보게 되는 안목을 기르는 것을 성장이라 본다.
- `샐리`: 회사 내에서의 성장을 하려면 어떻게 해야할지, 이젠 고민해봐야할 때!

> <strong><i>p23. 상황이 이렇다 보니 유지보수 업무나 기존 코드를 확장하는 일을 주로 하다 보면 새로운 기술을 접할 기회가 줄어들고 개발자로서 성장하지 못한다는 생각을 가질 수 있다. 하지만 언젠가 기회는 온다. 오래된 서비스라도 일부 또는 전체를 새로 만들어야 하는 상황이 발생한다. 이때를 노리면 된다.</i></strong> 🐧

- `펭귄`: **기회는 온다!**

> <strong><i>p28. 경력과 무관하게 많은 개발자가 업무 관리를 중요하지 않게 여기는 경향이 컸다.</i></strong> 🌵

- `펭귄`: 업무 관리는 업무를 하는 개발자 뿐만 아니라 일정 조율 및 리소스를 파악하는 조직장의 능력도 중요한 것 같다.

> <strong><i>p28. 지금 생각해보면 가장 큰 문제는 개발 리더 부재였다. ... 신입 개발자 2명이 기능 요구 사항을 분석한다는 것은 버거운 일이다.</i></strong> 🐧

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 2장. 구현 기술과 학습

> <strong><i>p34. 당장 해결해야 할 문제든 가까운 미래에 발생할 문제든 눈앞에 닥쳤을 때 알맞은 구현 기술을 찾는 건 쉽지 않다. 그래서 문제 해결 능력을 향상하기 위해 평소에 구현 기술을 탐색하고 학습해야 한다.</i></strong> 🌵🐧

> <strong><i>p37. 일단 처음 접하는 기술을 익힐 때는 핸즈온이나 동영상 강의 또는 튜토리얼 문서로 빠르게 감을 잡아야 한다.</i></strong> 🐧

- `펭귄`: 초기에는 확실히 “핸즈온 > 동영상 > 튜토리얼 문서" 순으로 좋고, 나중에 어느 정도 궤도에 오르면 문서나 책을 보는 게 좋은 것 같다.
- `샐리`: 책보다는 영상매체로 먼저 입문하는게 좋을 것 같다!

> <strong><i>p37. 예전에는 내가 사용하는 기술의 내부 동작 원리에 대해서도 미리 알아야 한다고 생각했지만 지금은 그렇지 않다. ... 어떤 기술을 깊게 이해해야 하는 순간이 있고 이때 시간을 더 들여 깊은 지식을 학습하고 연습하면 된다.</i></strong> 🌵🐤

- `샐리`: 학교 다닐 때 첫 장부터 마지막 장까지 세세히 훑어보던 내가 생각이 난다. 미련한 방법이었던거 같기도..
- `튜브`: 내부 원리를 알아야 제대로 공부했다는 느낌이 들기는 하지만, 처음부터 너무 오래 걸리고 어려워지는 단점이 너무 큰 것 같다. 일단 쓰다 보면 자연스럽게 원리를 생각하게 된다.
- `펭귄`: 처음에 급하게 땜빵을 하더라도 기록해두면 나중에 또 쓰여서 더 깊게 배우게 되는 것 같다.

> <strong><i>p42. 미리 탐색하고 핸즈온을 해보면서 왜 주목받는지 이해하려 노력하면 언젠가 내가 그 기술을 적용하려 할 때 수월해질 것이다. 또한 이러한 노력으로 개발자로서 미래 경쟁력을 유지할 수 있다.</i></strong> 🌵🐧

> <strong><i>p44. 코드를 살펴보니 문서를 조회하려는 사용자 아이디를 받아 필드에 저장하고, 다른 메서드가 그 필드에 담긴 값을 사용자 아이디로 사용하고 있었다. 여러 스레드가 같은 필드를 사용하다 보니 사용자 요청을 처리하는 스레드에서 설정한 사용자 아이디가 다른 스레드에 의해 변경된 것이다.</i></strong> 🐧

> <strong><i>p45. 주니어 개발자라면 유행과 상관없는 지식을 1년에 1개 이상 학습하자. HTTP 프로토콜, 네트워크 프로그래밍 기초, 동시성 처리, 프로그래밍 언어 등 유행에 상관 없이 개발의 기초가 되는 중요한 내용이 많다. 이러한 기초 지식을 꾸준히 학습해야 기본기가 튼튼한 개발자로 성장할 수 있다.</i></strong> 🌵🐧

> <strong><i>p47. 어떤 기술을 도입할 때는 보수적으로 고민하고 다음과 같은 내용을 신경 써야 한다.
>
> - 신뢰 구축
> - 함께 할 동료
> - 타당성
> - 점진적 적용
> - 시장 상황</i></strong> 🌵🐤🐧

- `샐리`: 동료에게 신뢰를 받아둬야 어떤 기술이나 아키텍처를 도입할 때 용이할 것이다.

> <strong><i>p49. 하지만 왜 도입하려고 하는지 이유를 물어보면 단지 웹플럭스가 성능이 좋다고 들어서라는 답을 들을 때가 많았다. </i></strong> 🐤

- `샐리`: 스스로도 이걸 왜 하는지 인지하고 있어야, 남을 설득하기 편할 것이다.

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 3장. 소프트웨어 가치와 비용

> <strong><i>p56. 소프트웨어 유지보수는 이전과 동일한 동작을 유지하는 것이 아니다. 변화하는 세상에서 유용함을 유지하는 것이다.</i></strong> 🌵🐤🐧

- `샐리`: SI 회사에서도 기존 동작을 유지할 뿐만아니라, 차세대 작업과 같이 이후에도 유용하게 이 프로그램을 유지할 수 있도록 노력하는 작업을 포함하는 것 같다!

> <strong><i>p60. 세상의 변화에 맞춰 소프트웨어도 함께 변해야 가치를 유지할 수 있는데 변경 비용이 많이 들면 소프트웨어를 변경하기 어렵다. 소프트웨어를 바꾸지 못하니 소프트웨어 가치를 유지하기도 어려워진다.</i></strong> 🐧

> <strong><i>p60. 개발자는 흔히 "기존 코드를 바꾸는 것보다 다시 만드는 게 더 빨라요"란 말을 한다.</i></strong> 🐤

- `샐리`: 반은 맞고 반은 틀린 것 같다. 코드를 새로 짜는게 더 빠를 순 있지만, 그 코드를 검증하고, 그 코드로 보직장을 설득하는 것은 오래걸리기도 하고 쉽지도 않다!

> <strong><i>p62. 또한 유지보수를 하면서 얻는 역량과 신규 프로젝트를 할 때 얻는 역량이 다르다고 본다. 신규 프로젝트를 진행할 때는 새로운 기술을 사용할 기회가 생긴다면 유지보수를 할 때는 소프트웨어 운영 과정에 필요한 역량을 쌓을 기회가 생긴다.</i></strong> 🐧

- `펭귄`: 확실히 유지보수를 하면서 “좋은 코드란 무엇인가?”라는 나만의 기준이 생기고 객체지향 프로그래밍과 같은 패러다임이나 계층 분리, DDD 등을 공부하게 되는 것 같다.

> <strong><i>p65. 유명한 패러다임과 패턴, 프로세스, 아키텍처 등은 빠른 변화에 어떻게 대응할지에 초점이 맞춰져 있다. 세상의 변화에 소프트웨어가 어떻게 변경되는지에 따라 소프트웨어 가치가 달라진다는 점을 생각하면 당연하다.</i></strong> 🌵

- `튜브`: 유명한 방법론들이 그렇다는 것은 그만큼 소프트웨어 가치가 중요하다는 것을 보여주는 것 같다.

> <strong><i>p66. 소프트웨어 전달 성과가 올라가면 버그 수정, 패치같이 예정에 없던 작업이나 재작업 비율이 줄고 새 작업에 더 많은 시간을 투입할 수 있기 때문에 소프트웨어 가치를 높이는 데 집중할 수 있게 된다.</i></strong> 🌵

- `튜브`: 차이가 점점 누적된다!

> <strong><i>p68. 잘 돌아가면 건들지 마! </i></strong> 🐤

- `샐리`: 보수적인 회사에서 자주 듣는 말!
- `튜브`: 계속 잘 돌아가는 걸 보장하면서 고칠 수 있는 방법은 없을까?

> <strong><i>p68. 잘 돌아가는 코드라 해도 세상에 맞춰 변화할 수 있도록 더 나은 코드, 더 나은 구조로 변경할 수 있는 용기가 우리에게 필요하다.</i></strong> 🐧

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 4장. 코드 이해

> <strong><i>p77. 그러니 다이어그램을 그릴 때는 어떤 정보를 제공하기 위해 다이어그램을 그리는지 분명히 하고 목적에 맞는 요소만 포함하도록 하자.</i></strong> 🐧

- `펭귄`: 주요 로직만 추상화해서 다이어그램만 그려놓아도 오류 분석이나 로직 추가할 때도 큰 도움이 되는 것 같다.

> <strong><i>p81. 스크래치 리팩터링은 코드 개선이 아닌 코드 이해가 목적이므로 리팩터링한 결과는 반영하지 않고 다시 원래대로 되돌린다.</i></strong> 🌵🐧

- `펭귄`: 용어가 있는 줄은 몰랐지만 리팩토링 시도하다가 롤백한 케이스가 종종 있었는데 그때마다 시스템에 대한 이해가 높아졌던 것 같다.
- `튜브`: 저렇게까지 할 필요가 있을까 생각할 정도로 신기하다.

> <strong><i>p86. 이름은 짧을수록 좋지만 사용 범위가 넓다면 서술적인 이름을 사용해야 한다. </i></strong> 🐤

- `샐리`: 이름이 길어도 되니까 용도를 쉽게 알아볼 수 있는 이름이 더 좋다.
- `펭귄`: 개인적으로 가독성이 좋은 이름이 최고라 생각하고, 혼자 결정하기 힘들다면 툴(ex. Copilot, ChatGPT)의 도움을 받는 게 정신적으로 좋다.

> <strong><i>p88. if 구조가 복잡할 때 if 조건을 역으로 바꾸면 else가 없다는 사실을 빨리 알 수 있고, 그만큼 조건을 기억할 범위도 좁아진다. 또한 코드 들여쓰기(깊이)가 줄어들기 때문에 코드 복잡도가 낮아진다. 따라서 코드 분석을 쉽게 할 수 있다. </i></strong> 🐤

- `샐리`: 많은 조건문으로 인한 들여쓰기가 가독성을 해칠때가 많다. 조건문을 줄이는 테크닉이 그 어떤 복잡한 구조론보다 유용했다.

> <strong><i>p89. 일반적으로 변수가 사용되는 범위가 넓거나 변수 개수가 많을 때, 또 변수 변경이 빈번하거나 변수 용도가 중간에 바뀔 때 코드 분석 과정에서 기억해야 할 내용이 많아져 인지 부하 증가로 이어진다.</i></strong> 🌵

- `샐리`: 규칙적인 위치에서 변수를 수정하거나, 아예 수정하는 함수를 파는 것도 괜찮은 것 같다. 한 변수에 들어갈 수 있는 값을 enum이나 const로 정해두는 것도 좋은 방법인 것 같다.
- `펭귄`: 그래서 변수 선언은 보통 해당 변수가 쓰이는 로직 가까이에 선언하거나 중간 로직이 길면 별도 함수로 빼서 읽다가 흐름이 끊기지 않게 하는 것 같다.

> <strong><i>p90. 어떤 의미를 부여하거나 새로운 타입으로 변환할 때 변수를 사용하면 코드를 분석하는 데 도움이 된다.</i></strong> 🌵

> <strong><i>p98. 타입을 추가했을 때 올라가는 코드 복잡도보다 하나의 타입을 여러 매서드의 파라미터 타입으로 사용하면서 늘어나는 코드 분석 시간이 더 큰 문제다.</i></strong> 🌵

> <strong><i>p102. 길지 않은 코드는 결국 추상화 수준을 맞추는 것과 연결된다. </i></strong> 🐤

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 5장. 응집도와 결합도

> <strong><i>p112. 응집도는 결국 수정 비용과 관련이 있다. 응집도가 높으면 관련 코드가 한곳에 모여 있게 되고 관련되지 않은 코드는 포함하지 않는다. 역할에 따라 클래스가 자연스럽게 클래스 길이가 줄고, 메서드 단위로 작성되기 때문에 가독성이 좋아진다. 따라서 코드 분석 시간을 줄여준다.</i></strong> 🐧

- `펭귄`: 최근에 응집도를 높이는 방향으로 코드를 짰던 적이 있는데, 확실히 클래스 길이가 줄었는데 그만큼 파일 개수가 늘어서 장단점이 있는 것 같다.
- `샐리`: 최근에 20000줄 되는 코드를 수정하려고 한 적이 있었는데, 생각보다 단일 책임 원칙을 지키기가 어려웠다.

> <strong><i>p114. 변경할 이유가 적을수록 응집도가 올라간다.</i></strong> 🍋

- `샐리`: 응집도라는 말이 조금은 안어울리는 것 같다. 오히려 ‘분리된 정도’ 쯤으로 볼 수 있지 않을까?
- `튜브`: 어쩌면 번역의 문제일 수도 있을 것 같다. 역할이 응집된 정도로 이해할 수 있지 않을까?

> <strong><i>p124. 결합도를 낮추기 위해 추상화 타입을 중간에 위치시키거나 이벤트를 사용하면 두 코드를 직접 연결하지 않고 간접적으로 연결하게 된다. 두 코드가 간접적으로 연결되어 있기 때문에 직접 연결된 코드에 비해 코드를 분석하는 데 더 많은 노력이 들어간다.</i></strong> 🐧🌵

- `샐리`: 회사에서 이벤트 대신 인터럽트를 쓰는 경우가 많다. 인터럽트 방식은 코드로 읽을 때 동작 방식이 직관적이지는 않아서 힘들다고 생각했었는데, 인터럽트가 이벤트와 비슷한 역할이라고 생각하면, 해당 구조가 결합도를 낮추는 데 도움이 되기 때문에 적용시켰구나 하고 이해가 갔다.

> <strong><i>p125. 따라서 추상화나 이벤트를 적용할 때는 결합도 감소, 응집도 증가, 변경 비용 감소, 테스트 가능성 등 얻을 수 있는 이점을 따져봐야 한다. 이점이 별로 없다면 추상화 타입을 사용하지 않고 구현만 분리해서 응집도를 높이는 것도 좋은 선택이 될 수 있다.</i></strong>🌵

- `샐리`: 추상화를 수행하지 않았을 때 보는 손해가 없다면 그냥 놔두는게 좋을지도! 코드짤 때 고려할 요소는 적을수록 좋은 것 같다.

> <strong><i>p125, 127. 어떤 형태의 결합이 존재하는지 알면 결합도를 높이지 않는 방향으로 코드를 작성하는 데 도움이 된다. 공통결합은 여러 모듈이 동일한 글로벌 데이터에 접근할 때 발생한다. 시간적 결합은 단지 함께 실행해야 하므로 두 기능을 한 모듈에 묶을 때 발생한다. 만약 모듈/시스템 데이터를 변경할 때 다른 모듈/시스템 데이터도 함께 변경해야 한다면 논리 결합이 발생한다. </i></strong> 🍋

- `샐리`: 결합의 종류에 대해 알게 되어서 좋았다.

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 6장. 리팩터링

> <strong><i>p132. 이런 작업은 코드를 더 길고 복잡하게 만든다. 중복된 코드도 늘어나고 이상한 이름도 그대로 사용한다.</i></strong> 🐤

> <strong><i>p132. 불과 몇 달 전에 내가 만든 코드도 레거시가 될 수 있다. 내가 만든 코드지만 수정하기 두렵다면 그게 바로 레거시다.</i></strong> 🌵

> <strong><i>p133. 복잡하고 수정하기 힘든 레거시 코드를 만나면 당연히 투덜댈 수 있다. 하지만 레거시는 폄하 대상이 아니다. 레거시가 있었기에 서비스가 굴러가고 수익이 난 것이다.</i></strong> 🐤

> <strong><i>p135. 가장 쉽지만 가장 부담되는 리펙터링이 코드 삭제다. ... 왜 주석 처리했는지 몰라서... 나중에 다시 사용할지 몰라서... </i></strong> 🐤

> <strong><i>p135. 이런 이유로 삭제하기 두렵다면 해당 코드에 TODO 주석을 추가하자.</i></strong> 🐤

> <strong><i>p140. 보이는 이름과 실제 의미가 일치하지 않으면 코드를 분석할 때 혼란을 겪게 된다.</i></strong> 🐤

> <strong><i>p158. 그리고 복잡한 코드보다 이해하기 좋은 코드가 주는 이점이 훨씬 크다.</i></strong> 🐤

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 7장. 테스트

> <strong><i>p2. 예시 인용</i></strong> 🐧🌵🍋

- `펭귄`: 펭귄은 귀엽습니다.

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 8장. 아키텍처 · 패턴

> <strong><i>p2. 예시 인용</i></strong> 🐧🌵🍋

- `펭귄`: 펭귄은 귀엽습니다.

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 9장. 업무 관리

> <strong><i>p2. 예시 인용</i></strong> 🐧🌵🍋

- `펭귄`: 펭귄은 귀엽습니다.

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 10장. 정리하고 공유하기

> <strong><i>p2. 예시 인용</i></strong> 🐧🌵🍋

- `펭귄`: 펭귄은 귀엽습니다.

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 11장. 리더와 팔로워

> <strong><i>p2. 예시 인용</i></strong> 🐧🌵🍋

- `펭귄`: 펭귄은 귀엽습니다.

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>

---

## 💬 느낀점

<table>
  <thead>
    <tr>
      <th width='10%'>팀원</th>
      <th width='90%'>느낀점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align='center'><code>펭귄</code></td>
      <td></td>
    </tr>
    <tr>
      <td align='center'><code>샐리</code></td>
      <td></td>
    </tr>
    <tr>
      <td align='center'><code>튜브</code></td>
      <td></td>
    </tr>
  </tbody>
</table>

<sup><a href="#-목차">⬆️ 위로 이동</a></sup>
